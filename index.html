<meta name='viewport' content='width=device-width, initial-scale=1'/><!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8">
  <title>Vinyl Scratch Demo</title>
  <style>
    body { font-family: sans-serif; padding: 2rem; text-align: center; }
    button, select, input { margin: 0.5rem; padding: 0.7rem 1.2rem; font-size: 1rem; }
  </style>
</head>
<body>
  <h1>üéöÔ∏è Vinyl Scratch Recorder</h1>

  <button id="recordBtn">üî¥ Start opname</button>
  <button id="stopBtn" disabled>‚èπ Stop opname</button>

  <div>
    <label>BPM: <input id="bpm" type="number" value="100" min="60" max="180"></label>
  </div>

  <div>
    <select id="pattern">
      <option value="fast">‚ö° Fast Cut</option>
      <option value="swing">üéµ Swing</option>
      <option value="stagger">ü•Å Stagger</option>
    </select>
    <button id="renderBtn" disabled>üéß Render Scratch</button>
  </div>

  <div id="output"></div>

  <script>
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let mediaRecorder, chunks = [], recordedBuffer;

    const recordBtn = document.getElementById("recordBtn");
    const stopBtn = document.getElementById("stopBtn");
    const renderBtn = document.getElementById("renderBtn");
    const bpmInput = document.getElementById("bpm");
    const patternSel = document.getElementById("pattern");
    const output = document.getElementById("output");

    // Recording
    recordBtn.onclick = async () => {
      audioCtx.resume();
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      mediaRecorder = new MediaRecorder(stream);
      chunks = [];
      mediaRecorder.ondataavailable = e => chunks.push(e.data);
      mediaRecorder.onstop = async () => {
        const blob = new Blob(chunks, { type: "audio/webm" });
        const buf = await blob.arrayBuffer();
        recordedBuffer = await audioCtx.decodeAudioData(buf);
        renderBtn.disabled = false;
        output.innerHTML = "<p>‚úÖ Opname klaar! Kies een scratch en render.</p>";
      };
      mediaRecorder.start();
      recordBtn.disabled = true;
      stopBtn.disabled = false;
    };

    stopBtn.onclick = () => {
      mediaRecorder.stop();
      stopBtn.disabled = true;
      recordBtn.disabled = false;
    };

    // Scratch curves
    function makeCurve(type, samples, beatDur) {
      let arr = new Float32Array(samples);
      for (let i = 0; i < samples; i++) {
        let t = i / samples;
        if (type === "fast") {
          arr[i] = Math.sin(2 * Math.PI * 8 * t); // snelle sinus
        } else if (type === "swing") {
          arr[i] = Math.sin(2 * Math.PI * 2 * t) ** 3; // langere glij met swing
        } else if (type === "stagger") {
          arr[i] = Math.sin(2 * Math.PI * 3 * t) * (t < 0.5 ? 1 : 0.5); // ongelijk
        }
      }
      return arr;
    }

    // Render scratch into new buffer
    async function renderScratch(audioBuffer, bpm, pattern) {
      const beatDur = 60 / bpm;
      const duration = beatDur * 4; // scratch van 4 beats
      const offline = new OfflineAudioContext(1, audioCtx.sampleRate * duration, audioCtx.sampleRate);

      const samples = Math.floor(duration * audioCtx.sampleRate);
      const curve = makeCurve(pattern, samples, beatDur);

      const scratchBuf = offline.createBuffer(1, samples, audioCtx.sampleRate);
      const inData = audioBuffer.getChannelData(0);
      const outData = scratchBuf.getChannelData(0);

      for (let i = 0; i < samples; i++) {
        // Map curve [-1,1] naar positie in input buffer
        let pos = Math.floor(((curve[i] + 1) / 2) * (inData.length - 1));
        outData[i] = inData[pos];
      }

      const bufSource = offline.createBufferSource();
      bufSource.buffer = scratchBuf;
      bufSource.connect(offline.destination);
      bufSource.start();

      const rendered = await offline.startRendering();
      return rendered;
    }

    // Render + playback
    renderBtn.onclick = async () => {
      const bpm = parseInt(bpmInput.value);
      const pattern = patternSel.value;
      output.innerHTML = "<p>‚è≥ Scratch renderen...</p>";

      const scratch = await renderScratch(recordedBuffer, bpm, pattern);

      // Play
      const src = audioCtx.createBufferSource();
      src.buffer = scratch;
      src.connect(audioCtx.destination);
      src.start();

      // Export WAV
      const wav = audioBufferToWav(scratch);
      const blob = new Blob([new DataView(wav)], { type: "audio/wav" });
      const url = URL.createObjectURL(blob);
      output.innerHTML = `<audio controls src="${url}"></audio><br>
                          <a href="${url}" download="scratch.wav">üíæ Download Scratch</a>`;
    };

    // Util: AudioBuffer ‚Üí WAV
    function audioBufferToWav(buffer) {
      const numOfChan = buffer.numberOfChannels;
      const length = buffer.length * numOfChan * 2 + 44;
      const buffer2 = new ArrayBuffer(length);
      const view = new DataView(buffer2);
      const channels = [];
      let pos = 0;

      function setUint16(data) { view.setUint16(pos, data, true); pos += 2; }
      function setUint32(data) { view.setUint32(pos, data, true); pos += 4; }

      // RIFF chunk descriptor
      setUint32(0x46464952);
      setUint32(length - 8);
      setUint32(0x45564157);

      // FMT sub-chunk
      setUint32(0x20746d66);
      setUint32(16);
      setUint16(1);
      setUint16(numOfChan);
      setUint32(buffer.sampleRate);
      setUint32(buffer.sampleRate * 2 * numOfChan);
      setUint16(numOfChan * 2);
      setUint16(16);

      // data sub-chunk
      setUint32(0x61746164);
      setUint32(length - pos - 4);

      // write interleaved data
      for (let i = 0; i < numOfChan; i++)
        channels.push(buffer.getChannelData(i));

      let offset = 0;
      while (pos < length) {
        for (let i = 0; i < numOfChan; i++) {
          let sample = Math.max(-1, Math.min(1, channels[i][offset]));
          sample = sample < 0 ? sample * 0x8000 : sample * 0x7fff;
          view.setInt16(pos, sample, true);
          pos += 2;
        }
        offset++;
      }
      return buffer2;
    }
  </script>
</body>
</html>