<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sample Scratcher</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #0e0e0e;
      --panel: #171717;
      --panel-elev: #1d1d1d;
      --line: #2a2a2a;
      --text: #f1f1f1;
      --muted: #a7a7a7;
      --muted-2: #8b8b8b;
      --accent: #1a9d4a;
      --accent-hover: #22c55e;
      --green: #22c55e;
      --danger: #ef4444;
      --white: #ffffff;
      --shadow: 0 10px 30px rgba(0, 0, 0, .3);
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: var(--text);
      background: radial-gradient(1000px 700px at 10% -10%, #121212, #0b0b0b);
    }

    header {
      padding: 18px 22px;
      border-bottom: 1px solid var(--line);
      background: #0b0b0b;
    }

    header h1 {
      margin: 0;
      font-size: 28px;
      letter-spacing: .5px;
      font-family: Oswald, sans-serif;
      font-weight: 700;
    }

    main {
      max-width: 1100px;
      margin: 0 auto;
      padding: 20px;
      display: grid;
      gap: 14px;
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 14px;
      overflow: hidden;
    }

    .panel.elev {
      background: var(--panel-elev);
      box-shadow: var(--shadow);
      border-color: #262626;
    }

    .section-title {
      margin: 0 0 10px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .section-title h2 {
      margin: 0;
      font-size: 22px;
      font-family: Oswald, sans-serif;
      font-weight: 600;
      letter-spacing: .3px;
    }

    .section-sub {
      margin: -6px 0 8px;
      color: var(--muted-2);
      font-size: 14px;
    }

    .dropzone {
      position: relative;
      display: grid;
      place-items: center;
      min-height: 260px;
      border: 2px dashed var(--line);
      border-radius: 18px;
      background: #121212;
      cursor: pointer;
      transition: transform .18s ease, border-color .2s ease, background .2s ease, box-shadow .2s ease;
    }

    .dropzone:hover {
      border-color: var(--accent-hover);
      transform: translateY(-1px);
      box-shadow: 0 10px 24px rgba(0, 0, 0, .25);
    }

    .dropzone.hover {
      border-color: var(--accent);
      background: #0f1511;
    }

    .dz-inner {
      text-align: center;
      line-height: 1.6;
    }

    .big-plus {
      font-size: 60px;
      font-weight: 700;
      font-family: Oswald, sans-serif;
      display: block;
    }

    .dz-title {
      font-size: 18px;
      font-weight: 600;
    }

    .dz-browse {
      font-size: 16px;
      font-weight: 600;
      color: var(--accent);
      text-decoration: underline;
    }

    .dz-browse:hover {
      color: var(--accent-hover);
    }

    input[type="file"] {
      display: none;
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }

    button,
    input,
    select {
      font-size: 16px;
      padding: 10px 14px;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: #151515;
      color: var(--text);
      transition: transform .12s ease, background .18s ease, box-shadow .18s ease, border-color .18s ease;
    }

    button {
      cursor: pointer;
    }

    button:hover {
      transform: translateY(-1px);
    }

    .primary {
      background: var(--accent);
      color: #000;
      border-color: transparent;
    }

    .primary:hover {
      background: var(--accent-hover);
    }

    .ghost {
      background: #141414;
    }

    .round-icon {
      width: 64px;
      height: 64px;
      border-radius: 999px;
      display: grid;
      place-items: center;
      border: 1px solid var(--line);
      background: linear-gradient(#121212, #0e0e0e);
      margin: 10px;
      box-shadow: 0 8px 20px rgba(0, 0, 0, .25), inset 0 1px 0 rgba(255, 255, 255, .05);
    }

    .round-icon:active {
      transform: scale(.96);
    }

    .record-dot {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--danger);
      box-shadow: 0 0 0 6px rgba(239, 68, 68, .12);
    }

    .stop-square {
      width: 18px;
      height: 18px;
      background: var(--white);
      box-shadow: 0 0 0 6px rgba(255, 255, 255, .1);
    }

    .rec-controls-wrap {
      display: grid;
      place-items: center;
      padding: 10px 0 2px;
    }

    .rec-controls {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 16px;
      background: #101010;
      border: 1px solid #242424;
      border-radius: 999px;
      padding: 8px 14px;
      box-shadow: var(--shadow);
    }

    .rec-status {
      text-align: center;
      color: var(--muted);
      margin-top: 6px;
      min-height: 18px;
    }

    canvas {
      width: 100%;
      background: #000;
      border: 1px solid var(--line);
      border-radius: 10px;
      height: 160px;
      touch-action: none;
    }

    /* Preselection – smaller, subtle */
    #preCanvas {
      height: 80px;
      background: #0a0a0a;
      cursor: crosshair;
    }

    .handles {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      color: var(--muted);
      font-size: 13px;
      margin-top: 6px;
    }

    .handles .center {
      text-align: center;
      color: #d7d7d7;
      font-weight: 600;
    }

    .tiny {
      font-size: 13px;
      padding: 6px 10px;
    }

    .pill {
      border-radius: 999px;
      padding: 8px 12px;
    }

    /* Settings controls */
    .settings-row {
      display: flex;
      flex-wrap: wrap;
      align-items: flex-end;
      gap: 20px;
    }

    .field label {
      font-size: 13px;
      color: var(--muted);
      display: inline-block;
      margin-bottom: 6px;
    }

    /* Green themed slider */
    input[type=range] {
      -webkit-appearance: none;
      appearance: none;
      width: 280px;
      height: 6px;
      border-radius: 999px;
      background: #2a2a2a;
      outline: none;
    }

    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--accent);
      border: 2px solid #0e0e0e;
      box-shadow: 0 2px 8px rgba(0, 0, 0, .35);
      transition: transform .12s ease, background .18s ease;
    }

    input[type=range]::-webkit-slider-thumb:hover {
      background: var(--accent-hover);
      transform: scale(1.06);
    }

    input[type=range]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--accent);
      border: none;
      box-shadow: 0 2px 8px rgba(0, 0, 0, .35);
    }

    input[type=range]::-moz-range-track {
      background: #2a2a2a;
      height: 6px;
      border-radius: 999px;
    }

    /* Switch */
    .switch {
      position: relative;
      width: 56px;
      height: 32px;
      background: #222;
      border-radius: 999px;
      border: 1px solid var(--line);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      padding: 4px;
    }

    .switch .knob {
      width: 24px;
      height: 24px;
      background: #666;
      border-radius: 50%;
      transition: transform .15s, background .15s;
    }

    .switch.on {
      background: #112c19;
      border-color: #143e20;
    }

    .switch.on .knob {
      transform: translateX(24px);
      background: var(--accent);
    }

    .status {
      min-height: 20px;
      color: var(--muted);
    }

    /* Effects grid */
    .preset-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
      gap: 14px;
    }

    .preset-card {
      background: #1e1e1e;
      border: 1px solid #2a2a2a;
      border-radius: 16px;
      padding: 14px;
      display: grid;
      gap: 10px;
      box-shadow: var(--shadow);
    }

    .preset-card h3 {
      margin: 0;
      font-size: 18px;
      font-family: Oswald, sans-serif;
    }

    .mini-wrap {
      border-radius: 10px;
      overflow: hidden;
      background: #0a0a0a;
    }

    .mini-wave {
      width: 100%;
      height: 60px;
      background: #0a0a0a;
      display: block;
    }

    .curve-vis {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .curve {
      position: relative;
      border: 1px solid #2a2a2a;
      border-radius: 10px;
      background: #0a0a0a;
      padding: 8px;
    }

    .curve h4 {
      position: absolute;
      top: 6px;
      left: 10px;
      margin: 0;
      font-size: 12px;
      color: rgba(255, 255, 255, .5);
      font-weight: 600;
    }

    .curve canvas {
      width: 100%;
      height: 100px;
      border: none;
      background: transparent;
    }

    .preset-actions {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .preset-actions .primary,
    .preset-actions .btn-ghost {
      width: 100%;
    }

    .btn-ghost {
      background: #141414;
      border: 1px solid #2a2a2a;
      color: var(--text);
    }

    .meta {
      color: #6f6f6f;
      font-size: 13px;
    }

    .meta b {
      color: #cfcfcf;
      font-weight: 700;
    }
  </style>
</head>

<body>
  <header>
    <h1>Sample Scratcher</h1>
  </header>

  <main>
    <!-- 1) Load Sample – full dropzone with centered refined recording controls -->
    <section class="panel elev" id="loadPanel">
      <div id="dropzone" class="dropzone" tabindex="0" aria-label="Drag and drop audio here or browse files">
        <div class="dz-inner">
          <span class="big-plus">+</span>
          <div class="dz-title">Drag & Drop Sample</div>
          <div><span class="dz-browse" id="browseLink">Or Browse Files</span></div>
          <input id="fileInput" type="file" accept="audio/*" />
        </div>
      </div>
      <div class="rec-controls-wrap">
        <div class="rec-controls">
          <button id="recordBtn" class="round-icon" title="Record"><span class="record-dot"></span></button>
          <button id="stopBtn" class="round-icon" title="Stop" disabled><span class="stop-square"></span></button>
        </div>
        <div class="rec-status" id="recStatus">No sample loaded…</div>
      </div>
    </section>

    <section class="panel" id="prePanel">
      <div class="section-title">
        <h2 id="fileSubtitle">Preselection</h2>
        <div class="row">
          <button id="reloadSampleBtn" class="tiny pill ghost" disabled>Reset</button>
          <button id="prePlayBtn" class="tiny pill ghost" disabled>Preview</button>
          <button id="commitPreBtn" class="tiny pill primary" disabled>Cut Sample</button>
        </div>
      </div>
      <canvas id="preCanvas" width="900" height="80"></canvas>
      <div class="handles">
        <span>Cut start: <span id="preStartLbl">0.00s</span></span>
        <span class="center">Length: <span id="preLenLbl">0.00s</span></span>
        <span>Cut end: <span id="preEndLbl">0.00s</span></span>
      </div>
    </section>

    <!-- 3) Scratching Area -->
    <section class="panel">
      <div class="section-title">
        <h2>Scratching Area</h2>
      </div>
      <canvas id="waveCanvas" width="900" height="160" aria-label="Scratching waveform"></canvas>
      <div class="handles">
        <span>Start: <span id="clipStartLbl">0.00s</span></span>
        <span class="center">Length: <span id="clipLenLbl">0.15s</span></span>
        <span>End: <span id="clipEndLbl">0.15s</span></span>
      </div>
    </section>

    <!-- 4) Settings (Torque + Tail switch) -->
    <section class="panel">
      <div class="section-title">
        <h2>Settings</h2>
      </div>
      <div class="settings-row">
        <div class="field">
          <label for="bpm">BPM</label>
          <input id="bpm" type="number" value="120" min="40" max="300" step="1" />
        </div>
        <div class="field">
          <label>Tail after scratch</label><br>
          <span id="tailSwitch" class="switch" role="switch" aria-checked="false" tabindex="0"><span
              class="knob"></span></span>
          <span id="tailLbl" class="meta" style="margin-left:8px;">Off</span>
        </div>
        <div class="field">
          <label>Torque (<span>ms</span>) – platter ramp-in</label><br>
          <input id="torque" type="range" min="0" max="600" value="100" step="10" />
          <div class="meta"><b id="torqueVal">0</b> ms</div>
        </div>
      </div>
    </section>

    <!-- 5) Effects -->
    <section class="panel">
      <div class="section-title">
        <h2>Effects</h2>
      </div>
      <div id="presetGrid" class="preset-grid"></div>
    </section>
  </main>

  <template id="presetCardTpl">
    <div class="preset-card">
      <h3 class="pname"></h3>
      <div class="mini-wrap">
        <canvas class="mini-wave" width="300" height="54"></canvas>
      </div>
      <div class="meta"><span>Duration: <b class="beats">1 beat</b></span></div>
      <div class="preset-actions">
        <button class="playBtn primary">Listen</button>
        <button class="dlBtn btn-ghost">Download</button>
      </div>
    </div>
  </template>

  <script>
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    let mediaRecorder, chunks = [];
    let sampleBuffer = null;
    let originalSampleBuffer = null;
    let sampleFileName = '';

    let preStart = 0, preEnd = 0;
    let clipStart = 0, clipEnd = 0.15;

    let tailMode = 'none'; // 'none' | 'sample'
    let torqueMs = 0;    // platter ramp-in duration

    let rafId = null;
    let playhead = { active: false, startAt: 0, duration: 0, where: 'none', canvas: null, miniIdx: -1 };

    const recStatus = document.getElementById('recStatus');
    const fileInput = document.getElementById('fileInput');
    const dropzone = document.getElementById('dropzone');
    const browseLink = document.getElementById('browseLink');

    const recordBtn = document.getElementById('recordBtn');
    const stopBtn = document.getElementById('stopBtn');

    const fileSubtitle = document.getElementById('fileSubtitle');
    const preCanvas = document.getElementById('preCanvas');
    const preCtx = preCanvas.getContext('2d');
    const preStartLbl = document.getElementById('preStartLbl');
    const preEndLbl = document.getElementById('preEndLbl');
    const preLenLbl = document.getElementById('preLenLbl');
    const reloadSampleBtn = document.getElementById('reloadSampleBtn');
    const prePlayBtn = document.getElementById('prePlayBtn');
    const commitPreBtn = document.getElementById('commitPreBtn');

    const waveCanvas = document.getElementById('waveCanvas');
    const waveCtx = waveCanvas.getContext('2d');
    const clipStartLbl = document.getElementById('clipStartLbl');
    const clipEndLbl = document.getElementById('clipEndLbl');
    const clipLenLbl = document.getElementById('clipLenLbl');

    const bpmEl = document.getElementById('bpm');
    const tailSwitch = document.getElementById('tailSwitch');
    const tailLbl = document.getElementById('tailLbl');
    const torqueEl = document.getElementById('torque');
    const torqueVal = document.getElementById('torqueVal');
    const globalStatus = document.getElementById('globalStatus');

    const presetGrid = document.getElementById('presetGrid');
    const presetCardTpl = document.getElementById('presetCardTpl');

    // ==== helpers
    const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
    const lerp = (a, b, t) => a + (b - a) * t;
    function sampleLinear(chData, pos) { const i = Math.floor(pos), f = pos - i; const i2 = Math.min(chData.length - 1, i + 1); return lerp(chData[i] || 0, chData[i2] || 0, f); }
    function secToX(sec, duration, width) { const ratio = duration ? (sec / duration) : 0; return Math.round(clamp(ratio, 0, 1) * (width - 1)); }
    function xToSec(x, duration, width) { const ratio = x / (width - 1); return ratio * (duration || 0); }

    function fitCanvasToDisplay(canvas) { const dpr = window.devicePixelRatio || 1; const rect = canvas.getBoundingClientRect(); const need = canvas.width !== Math.round(rect.width * dpr) || canvas.height !== Math.round(rect.height * dpr); if (need) { canvas.width = Math.max(1, Math.round(rect.width * dpr)); canvas.height = Math.max(1, Math.round(rect.height * dpr)); } return dpr; }
    function canvasEventX(e, canvas) { const dpr = window.devicePixelRatio || 1; const r = canvas.getBoundingClientRect(); return clamp((e.clientX - r.left) * dpr, 0, canvas.width - 1); }

    function updateLabels() {
      clipStartLbl.textContent = (clipStart || 0).toFixed(2) + 's';
      clipEndLbl.textContent = (clipEnd || 0).toFixed(2) + 's';
      clipLenLbl.textContent = Math.max(0, (clipEnd - clipStart)).toFixed(2) + 's';
      preStartLbl.textContent = (preStart || 0).toFixed(2) + 's';
      preEndLbl.textContent = (preEnd || 0).toFixed(2) + 's';
      preLenLbl.textContent = Math.max(0, (preEnd - preStart)).toFixed(2) + 's';
      renderPresetGrid(true); updatePresetThumbnails();
    }

    // ==== drawing
    function drawPreWave() {
      const dpr = fitCanvasToDisplay(preCanvas);
      const Wp = preCanvas.width, Hp = preCanvas.height;
      preCtx.clearRect(0, 0, Wp, Hp);
      preCtx.fillStyle = '#0a0a0a'; preCtx.fillRect(0, 0, Wp, Hp);
      if (!sampleBuffer) return;
      const data = sampleBuffer.getChannelData(0);
      const step = Math.max(1, Math.floor(data.length / Wp));
      preCtx.strokeStyle = '#666'; preCtx.lineWidth = Math.max(1, dpr);
      preCtx.beginPath();
      for (let x = 0; x < Wp; x++) { const v = data[x * step] || 0; const y = (1 - (v + 1) / 2) * Hp; if (x === 0) preCtx.moveTo(x, y); else preCtx.lineTo(x, y); }
      preCtx.stroke();

      const sX = secToX(preStart, sampleBuffer.duration, Wp), eX = secToX(preEnd, sampleBuffer.duration, Wp);
      const a = Math.min(sX, eX), b = Math.max(sX, eX);
      preCtx.fillStyle = 'rgba(34,197,94,0.18)';
      preCtx.fillRect(a, 0, Math.max(1, b - a), Hp);
      preCtx.strokeStyle = '#22c55e'; preCtx.lineWidth = Math.max(2, 2 * dpr);
      preCtx.beginPath(); preCtx.moveTo(sX, 0); preCtx.lineTo(sX, Hp); preCtx.stroke();
      preCtx.beginPath(); preCtx.moveTo(eX, 0); preCtx.lineTo(eX, Hp); preCtx.stroke();

      if (playhead.active && playhead.where === 'pre') {
  const elapsed = Math.min(audioCtx.currentTime - playhead.startAt, preEnd - preStart);
  const x = secToX(elapsed, (preEnd - preStart), Wp) + a;
  preCtx.strokeStyle = '#ffffff'; preCtx.lineWidth = Math.max(1, dpr);
  preCtx.beginPath(); preCtx.moveTo(x, 0); preCtx.lineTo(x, Hp); preCtx.stroke();
}

    function drawMainWave() {
      const dpr = fitCanvasToDisplay(waveCanvas);
      const Wc = waveCanvas.width, Hc = waveCanvas.height;
      waveCtx.clearRect(0, 0, Wc, Hc);
      waveCtx.fillStyle = '#000'; waveCtx.fillRect(0, 0, Wc, Hc);
      if (!sampleBuffer) return;

      const data = sampleBuffer.getChannelData(0);
      const step = Math.max(1, Math.floor(data.length / Wc));
      waveCtx.strokeStyle = '#16a34a';
      waveCtx.lineWidth = Math.max(1, dpr);
      waveCtx.beginPath();
      for (let x = 0; x < Wc; x++) { const v = data[x * step] || 0; const y = (1 - (v + 1) / 2) * Hc; if (x === 0) waveCtx.moveTo(x, y); else waveCtx.lineTo(x, y); }
      waveCtx.stroke();

      const sX = secToX(clipStart, sampleBuffer.duration, Wc), eX = secToX(clipEnd, sampleBuffer.duration, Wc);
      const a = Math.min(sX, eX), b = Math.max(sX, eX);
      waveCtx.fillStyle = 'rgba(255,255,255,0.06)'; waveCtx.fillRect(a, 0, Math.max(1, b - a), Hc);

      waveCtx.strokeStyle = '#fff'; waveCtx.lineWidth = Math.max(2, 2 * dpr);
      waveCtx.beginPath(); waveCtx.moveTo(sX, 0); waveCtx.lineTo(sX, Hc); waveCtx.stroke();
      waveCtx.beginPath(); waveCtx.moveTo(eX, 0); waveCtx.lineTo(eX, Hc); waveCtx.stroke();

      // Play circle only (white mid bar removed for easier drag)
      const midX = Math.round((a + b) / 2);
      const r = 14 * dpr; const cy = Hc / 2;
      const isPlaying = playhead.active && playhead.where === 'main';
      waveCtx.beginPath(); waveCtx.arc(midX, cy, r, 0, Math.PI * 2); waveCtx.fillStyle = '#111'; waveCtx.fill(); waveCtx.strokeStyle = '#fff'; waveCtx.lineWidth = 2 * dpr; waveCtx.stroke();
      waveCtx.fillStyle = '#fff';
      if (!isPlaying) { const px = midX - 5 * dpr, py = cy - 7 * dpr; waveCtx.beginPath(); waveCtx.moveTo(px, py); waveCtx.lineTo(px, py + 14 * dpr); waveCtx.lineTo(px + 12 * dpr, cy); waveCtx.closePath(); waveCtx.fill(); }
      else { waveCtx.fillRect(midX - 6 * dpr, cy - 7 * dpr, 4 * dpr, 14 * dpr); waveCtx.fillRect(midX + 2 * dpr, cy - 7 * dpr, 4 * dpr, 14 * dpr); }

      if (playhead.active && playhead.where === 'main') {
        const p = clamp((audioCtx.currentTime - playhead.startAt) / playhead.duration, 0, 1);
        const x = a + p * (b - a);
        waveCtx.strokeStyle = '#ffffff'; waveCtx.lineWidth = Math.max(1, dpr);
        waveCtx.beginPath(); waveCtx.moveTo(x, 0); waveCtx.lineTo(x, Hc); waveCtx.stroke();
      }
    }

    function drawMiniFromBuffer(canvas, buffer, playPct = null) {
      const dpr = fitCanvasToDisplay(canvas);
      const ctx = canvas.getContext('2d');
      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0, 0, w, h);
      ctx.fillStyle = '#0a0a0a'; ctx.fillRect(0, 0, w, h);
      if (!buffer) return;
      const data = buffer.getChannelData(0);
      const step = Math.max(1, Math.floor(data.length / w));
      ctx.strokeStyle = '#16a34a'; ctx.lineWidth = Math.max(1, dpr);
      ctx.beginPath();
      for (let x = 0; x < w; x++) { const v = data[x * step] || 0; const y = (1 - (v + 1) / 2) * h; if (x === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y); }
      ctx.stroke();
      if (playPct != null) { const x = clamp(Math.round(playPct * (w - 1)), 0, w - 1); ctx.strokeStyle = '#fff'; ctx.lineWidth = Math.max(1, dpr); ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke(); }
    }

    function drawCurve(canvas, arr, lo, hi, label) {
      const dpr = fitCanvasToDisplay(canvas);
      const ctx = canvas.getContext('2d');
      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0, 0, w, h);
      ctx.fillStyle = '#0a0a0a'; ctx.fillRect(0, 0, w, h);
      if (!arr) return;
      ctx.strokeStyle = '#22c55e'; ctx.lineWidth = Math.max(1, dpr);
      ctx.beginPath();
      for (let i = 0; i < w; i++) {
        const t = w > 1 ? i / (w - 1) : 0; const idx = Math.floor(t * (arr.length - 1));
        const v = arr[idx];
        const y = (1 - (v - lo) / (hi - lo)) * h;
        if (i === 0) ctx.moveTo(i, y); else ctx.lineTo(i, y);
      }
      ctx.stroke();
      // subtle label inside
      ctx.fillStyle = 'rgba(255,255,255,.4)';
      ctx.font = `${12 * dpr}px system-ui, sans-serif`;
      const text = label || '';
      if (text) ctx.fillText(text, 10 * dpr, 18 * dpr);
    }

    // ==== load / record
    async function loadArrayBuffer(arr, name = '') {
      sampleBuffer = await audioCtx.decodeAudioData(arr);
      originalSampleBuffer = sampleBuffer;
      sampleFileName = name || 'Sample';
      fileSubtitle.textContent = sampleFileName;
      preStart = 0; preEnd = sampleBuffer.duration;
      clipStart = 0; clipEnd = Math.min(0.15, sampleBuffer.duration);
      recStatus.textContent = `Sample: ${sampleBuffer.duration.toFixed(2)}s @ ${sampleBuffer.sampleRate} Hz`;
      prePlayBtn.disabled = false; commitPreBtn.disabled = false; reloadSampleBtn.disabled = false;
      drawPreWave(); drawMainWave(); updateLabels(); renderPresetGrid(true); updatePresetThumbnails();
    }

    dropzone.addEventListener('click', () => fileInput.click());
    browseLink.addEventListener('click', (e) => { e.stopPropagation(); fileInput.click(); });
    dropzone.addEventListener('dragover', (e) => { e.preventDefault(); dropzone.classList.add('hover'); });
    dropzone.addEventListener('dragleave', () => dropzone.classList.remove('hover'));
    dropzone.addEventListener('drop', async (e) => { e.preventDefault(); dropzone.classList.remove('hover'); const file = e.dataTransfer.files?.[0]; if (!file) return; const arr = await file.arrayBuffer(); await loadArrayBuffer(arr, file.name); });
    fileInput.onchange = async (e) => { const file = e.target.files?.[0]; if (!file) return; const arr = await file.arrayBuffer(); await loadArrayBuffer(arr, file.name); };

    const startRecording = async () => {
      await audioCtx.resume();
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      mediaRecorder = new MediaRecorder(stream);
      chunks = [];
      mediaRecorder.ondataavailable = e => e.data && chunks.push(e.data);
      mediaRecorder.onstop = async () => { const blob = new Blob(chunks, { type: chunks[0]?.type || 'audio/webm' }); const arr = await blob.arrayBuffer(); await loadArrayBuffer(arr, 'Recorded sample'); };
      mediaRecorder.start();
      recordBtn.disabled = true; stopBtn.disabled = false; recStatus.textContent = 'Recording…';
    };
    recordBtn.onclick = startRecording;
    stopBtn.onclick = () => { if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop(); stopBtn.disabled = true; recordBtn.disabled = false; };

    // ==== Preselection interactions
    let preDragging = null; // 'start' | 'end' | 'move' | 'new'
    const HANDLE_EPS = 12 * (window.devicePixelRatio || 1);

    function preHitTest(x) {
      const sX = secToX(preStart, sampleBuffer?.duration, preCanvas.width);
      const eX = secToX(preEnd, sampleBuffer?.duration, preCanvas.width);
      const a = Math.min(sX, eX), b = Math.max(sX, eX);
      if (Math.abs(x - sX) <= HANDLE_EPS) return 'start';
      if (Math.abs(x - eX) <= HANDLE_EPS) return 'end';
      if (x > a && x < b) return 'move';
      return 'new';
    }

    function updatePreCursor(e) { if (!sampleBuffer) { preCanvas.style.cursor = 'not-allowed'; return; } const x = canvasEventX(e, preCanvas); const kind = preHitTest(x); preCanvas.style.cursor = (kind === 'move') ? 'grab' : (kind === 'start' || kind === 'end') ? 'ew-resize' : 'crosshair'; }

    preCanvas.addEventListener('pointermove', (e) => {
      if (!preDragging) updatePreCursor(e);
      if (!sampleBuffer || !preDragging) return;
      const x = canvasEventX(e, preCanvas);
      const sec = xToSec(x, sampleBuffer.duration, preCanvas.width);
      if (preDragging === 'start') preStart = Math.min(sec, preEnd - 0.005);
      else if (preDragging === 'end') preEnd = Math.max(sec, preStart + 0.005);
      else if (preDragging === 'move') { const width = preEnd - preStart; let ns = sec - width / 2; ns = clamp(ns, 0, (sampleBuffer.duration - width)); preStart = ns; preEnd = ns + width; }
      else if (preDragging === 'new') { preEnd = Math.max(sec, 0); preStart = Math.min(sec, preStart); }
      drawPreWave(); updateLabels();
    });
    preCanvas.addEventListener('pointerdown', (e) => { if (!sampleBuffer) return; preCanvas.setPointerCapture(e.pointerId); const x = canvasEventX(e, preCanvas); const ht = preHitTest(x); if (ht === 'new') { const sec = xToSec(x, sampleBuffer.duration, preCanvas.width); preStart = sec; preEnd = sec; } preDragging = ht; updatePreCursor(e); });
    preCanvas.addEventListener('pointerup', (e) => { preDragging = null; preCanvas.releasePointerCapture(e.pointerId); updatePreCursor(e); });
    preCanvas.addEventListener('pointerleave', () => { preDragging = null; preCanvas.style.cursor = 'crosshair'; });

    prePlayBtn.onclick = () => { if (!sampleBuffer) return; const src = audioCtx.createBufferSource(); const chs = sampleBuffer.numberOfChannels; const sr = sampleBuffer.sampleRate; const len = Math.max(1, Math.floor((preEnd - preStart) * sr)); const out = new AudioBuffer({ length: len, numberOfChannels: chs, sampleRate: sr }); for (let ch = 0; ch < chs; ch++) { const inData = sampleBuffer.getChannelData(ch); const outData = out.getChannelData(ch); const startIdx = Math.floor(preStart * sr); for (let i = 0; i < len; i++) { outData[i] = inData[startIdx + i] || 0; } } src.buffer = out; src.connect(audioCtx.destination); src.start(); startPlayhead('pre', (preEnd - preStart)); };

    commitPreBtn.onclick = () => {
      if (!sampleBuffer) return;
      const chs = sampleBuffer.numberOfChannels; const sr = sampleBuffer.sampleRate; const len = Math.max(1, Math.floor((preEnd - preStart) * sr)); const newBuf = new AudioBuffer({ length: len, numberOfChannels: chs, sampleRate: sr });
      for (let ch = 0; ch < chs; ch++) { const inData = sampleBuffer.getChannelData(ch); const outData = newBuf.getChannelData(ch); const startIdx = Math.floor(preStart * sr); for (let i = 0; i < len; i++) { outData[i] = inData[startIdx + i] || 0; } }
      sampleBuffer = newBuf; preStart = 0; preEnd = sampleBuffer.duration; clipStart = 0; clipEnd = Math.min(0.15, sampleBuffer.duration);
      drawPreWave(); drawMainWave(); updateLabels(); globalStatus.textContent = 'Preselection applied as new sample'; renderPresetGrid(true); updatePresetThumbnails();
    };

    reloadSampleBtn.onclick = () => {
  if (!originalSampleBuffer) return;
  sampleBuffer = originalSampleBuffer;   // restore
  preStart = 0;
  preEnd = sampleBuffer.duration;
  clipStart = 0;
  clipEnd = Math.min(0.20, sampleBuffer.duration);

  drawPreWave();
  drawMainWave();
  updateLabels();
  globalStatus.textContent = 'Sample reloaded to original state';
  renderPresetGrid(true);
  updatePresetThumbnails();
};

    // ==== main selection with play circle (no visible mid bar)
    let dragging = null; // 'start' | 'end' | 'move'
    const MAIN_HANDLE_EPS = 14 * (window.devicePixelRatio || 1);

    function isInsidePlayCircle(x) {
      const sX = secToX(clipStart, sampleBuffer?.duration, waveCanvas.width);
      const eX = secToX(clipEnd, sampleBuffer?.duration, waveCanvas.width);
      const a = Math.min(sX, eX), b = Math.max(sX, eX);
      const mid = (a + b) / 2;
      const dpr = (window.devicePixelRatio || 1);
      const r = 14 * dpr; return Math.abs(x - mid) <= r + 2 * dpr; // approximate (y centered)
    }

    function mainHitTest(x) {
      const sX = secToX(clipStart, sampleBuffer?.duration, waveCanvas.width);
      const eX = secToX(clipEnd, sampleBuffer?.duration, waveCanvas.width);
      const a = Math.min(sX, eX), b = Math.max(sX, eX);
      if (Math.abs(x - sX) <= MAIN_HANDLE_EPS) return 'start';
      if (Math.abs(x - eX) <= MAIN_HANDLE_EPS) return 'end';
      if (x > a && x < b && !isInsidePlayCircle(x)) return 'move'; // move only when not clicking the play circle
      return null;
    }
    function updateMainCursor(e) { if (!sampleBuffer) { waveCanvas.style.cursor = 'not-allowed'; return; } const x = canvasEventX(e, waveCanvas); const ht = mainHitTest(x); waveCanvas.style.cursor = ht === 'move' ? 'grab' : ht ? 'ew-resize' : 'crosshair'; }

    waveCanvas.addEventListener('pointerdown', (e) => {
      if (!sampleBuffer) return;
      waveCanvas.setPointerCapture(e.pointerId);
      const x = canvasEventX(e, waveCanvas);
      if (isInsidePlayCircle(x)) { if (playhead.active && playhead.where === 'main') { stopPlayhead(); } else { playClipSelection(); } return; }
      dragging = mainHitTest(x) || 'end'; updateMainCursor(e);
    });
    waveCanvas.addEventListener('pointermove', (e) => {
      if (!dragging) updateMainCursor(e);
      if (!sampleBuffer || !dragging) return;
      const x = canvasEventX(e, waveCanvas);
      const sec = xToSec(x, sampleBuffer.duration, waveCanvas.width);
      if (dragging === 'start') clipStart = Math.min(sec, clipEnd - 0.005);
      else if (dragging === 'end') clipEnd = Math.max(sec, clipStart + 0.005);
      else if (dragging === 'move') { const width = clipEnd - clipStart; let ns = sec - width / 2; ns = clamp(ns, 0, (sampleBuffer.duration - width)); clipStart = ns; clipEnd = ns + width; }
      drawMainWave(); updateLabels();
    });
    waveCanvas.addEventListener('pointerup', (e) => { dragging = null; waveCanvas.releasePointerCapture(e.pointerId); updateMainCursor(e); });
    waveCanvas.addEventListener('pointerleave', () => { dragging = null; waveCanvas.style.cursor = 'crosshair'; });

    function playClipSelection() {
      if (!sampleBuffer) return;
      const src = audioCtx.createBufferSource();
      const chs = sampleBuffer.numberOfChannels; const sr = sampleBuffer.sampleRate;
      const len = Math.max(1, Math.floor((clipEnd - clipStart) * sr));
      const out = new AudioBuffer({ length: len, numberOfChannels: chs, sampleRate: sr });
      for (let ch = 0; ch < chs; ch++) { const inData = sampleBuffer.getChannelData(ch); const outData = out.getChannelData(ch); const startIdx = Math.floor(clipStart * sr); for (let i = 0; i < len; i++) { outData[i] = inData[startIdx + i] || 0; } }
      src.buffer = out; src.connect(audioCtx.destination); src.start();
      startPlayhead('main', (clipEnd - clipStart));
    }

    // ==== Tail, torque & presets
    function setTail(on) { tailMode = on ? 'sample' : 'none'; tailSwitch.classList.toggle('on', on); tailSwitch.setAttribute('aria-checked', on ? 'true' : 'false'); tailLbl.textContent = on ? 'On' : 'Off'; renderPresetGrid(true); updatePresetThumbnails(); }
    setTail(false);
    const toggleTail = () => setTail(!(tailMode === 'sample'));
    tailSwitch.addEventListener('click', toggleTail);
    tailSwitch.addEventListener('keydown', (e) => { if (e.key === ' ' || e.key === 'Enter') { e.preventDefault(); toggleTail(); } });

    torqueEl.addEventListener('input', () => { torqueMs = parseInt(torqueEl.value, 10); torqueVal.textContent = `${torqueMs}`; renderPresetGrid(true); updatePresetThumbnails(); });

    function curveFromFormula(formula, samples, lo, hi) {
      let fn; try { fn = new Function('t', `return (${formula});`); } catch (err) { throw new Error('Formula error: ' + err.message); }
      const arr = new Float32Array(samples);
      for (let i = 0; i < samples; i++) { const t = samples > 1 ? i / (samples - 1) : 0; let v; try { v = fn(t); } catch (e) { v = 0; } if (!Number.isFinite(v)) v = 0; arr[i] = clamp(v, lo, hi); }
      return arr;
    }

    // platter ramp-in (speed) for tail
    function speedRampIndexIncrement(i, rampSamples) {
      if (rampSamples <= 0) return 1; // instant
      const t = clamp(i / rampSamples, 0, 1);
      // ease-out curve for spin-up
      return t; // linear to full speed; could use: return 1 - Math.pow(1 - t, 2);
    }

    // Compute how many output samples are needed so the rest of the source finishes
    function computeTailOutSamples(remainingSourceSamples, rampSamples) {
      const S = Math.max(0, remainingSourceSamples | 0);
      const R = Math.max(0, rampSamples | 0);
      if (R <= 0) return S; // no torque ramp

      // During the ramp, total source advanced ≈ (R-1)/2
      const rampAdvance = (R - 1) / 2;

      if (S <= rampAdvance) {
        // Solve quadratic: N(N-1)/(2R) >= S
        const N = Math.ceil((1 + Math.sqrt(1 + 8 * R * S)) / 2);
        return N;
      }
      return Math.ceil(R + (S - rampAdvance));
    }

    async function renderEffectToBuffer(preset) {
      if (!sampleBuffer) throw new Error('No sample loaded or recorded.');
      const bpm = parseFloat(bpmEl.value || '120'); const beatDur = 60 / (isFinite(bpm) ? bpm : 120);
      const beats = parseInt(preset.duration, 10) || 1; const scratchDur = beatDur * beats;
      const sr = sampleBuffer.sampleRate; const scratchSamples = Math.max(1, Math.floor(scratchDur * sr));
      const scratchCurve = curveFromFormula(preset.scratchFormula, scratchSamples, -1, 1);
      const gainCurve = curveFromFormula(preset.gainFormula, scratchSamples, 0, 1);

      const sStart = Math.floor(clipStart * sampleBuffer.sampleRate);
      const sEnd = Math.floor(clipEnd * sampleBuffer.sampleRate);
      const sLen = Math.max(1, sEnd - sStart);

      const tailSrcRemaining = Math.max(0, sampleBuffer.length - sStart);
      const rampSamples = Math.floor(sr * (torqueMs / 1000));
      const tailOutSamples = tailMode === 'none'
        ? 0
        : computeTailOutSamples(tailSrcRemaining, rampSamples);

      const outLen = scratchSamples + tailOutSamples;

      const out = new AudioBuffer({ length: outLen, numberOfChannels: sampleBuffer.numberOfChannels, sampleRate: sampleBuffer.sampleRate });

      // scratch part
      for (let ch = 0; ch < out.numberOfChannels; ch++) {
        const inData = sampleBuffer.getChannelData(ch); const outData = out.getChannelData(ch);
        for (let i = 0; i < scratchSamples; i++) { const u = (scratchCurve[i] + 1) * 0.5; const srcPos = sStart + u * (sLen - 1); const v = sampleLinear(inData, srcPos); outData[i] = v * gainCurve[i]; }
      }

      // tail with platter speed ramp-in (index increment from 0→1)
      if (tailOutSamples > 0) {
        const rampSamplesLocal = Math.floor(sr * (torqueMs / 1000));
        for (let ch = 0; ch < out.numberOfChannels; ch++) {
          const inData = sampleBuffer.getChannelData(ch);
          const outData = out.getChannelData(ch);
          let pos = sStart;
          for (let i = 0; i < tailOutSamples; i++) {
            const inc = speedRampIndexIncrement(i, rampSamplesLocal);
            const dst = scratchSamples + i;
            if (dst >= outLen || pos >= inData.length) break;
            outData[dst] = sampleLinear(inData, pos);
            pos += inc;
          }
        }
      }

      const offline = new OfflineAudioContext(out.numberOfChannels, out.length, out.sampleRate);
      const src = offline.createBufferSource(); src.buffer = out; src.connect(offline.destination); src.start();
      const rendered = await offline.startRendering();
      return rendered;
    }

    // ==== Presets
    let presets = [
      {
        name: "Classic",
        duration: "1",
        scratchFormula: "((((t%1+1)%1)>=0&&((t%1+1)%1)<0.25)?((2*(3*((((t%1+1)%1)-0)/0.25)*((((t%1+1)%1)-0)/0.25)-2*((((t%1+1)%1)-0)/0.25)*((((t%1+1)%1)-0)/0.25)*((((t%1+1)%1)-0)/0.25))-1)):0)+((((t%1+1)%1)>=0.25&&((t%1+1)%1)<0.5)?(-1*((2*(3*((((t%1+1)%1)-0.25)/0.25)*((((t%1+1)%1)-0.25)/0.25)-2*((((t%1+1)%1)-0.25)/0.25)*((((t%1+1)%1)-0.25)/0.25)*((((t%1+1)%1)-0.25)/0.25))-1))):0)+((((t%1+1)%1)>=0.5&&((t%1+1)%1)<0.75)?((2*(3*((((t%1+1)%1)-0.5)/0.25)*((((t%1+1)%1)-0.5)/0.25)-2*((((t%1+1)%1)-0.5)/0.25)*((((t%1+1)%1)-0.5)/0.25)*((((t%1+1)%1)-0.5)/0.25))-1)):0)+((((t%1+1)%1)>=0.75&&((t%1+1)%1)<1)?(-1*((2*(3*((((t%1+1)%1)-0.75)/0.25)*((((t%1+1)%1)-0.75)/0.25)-2*((((t%1+1)%1)-0.75)/0.25)*((((t%1+1)%1)-0.75)/0.25)*((((t%1+1)%1)-0.75)/0.25))-1))):0)",
        gainFormula: "1"
      },
      {
        name: "Classic 2",
        duration: "2",
        scratchFormula: "((((t%1+1)%1)>=0&&((t%1+1)%1)<0.125)?((2*(3*((((t%1+1)%1)-0)/0.125)*((((t%1+1)%1)-0)/0.125)-2*((((t%1+1)%1)-0)/0.125)*((((t%1+1)%1)-0)/0.125)*((((t%1+1)%1)-0)/0.125))-1)):0)+((((t%1+1)%1)>=0.125&&((t%1+1)%1)<0.25)?((0*(Math.sin(2*Math.PI*((((t%1+1)%1)-0.125)/0.125))))+1):0)+((((t%1+1)%1)>=0.25&&((t%1+1)%1)<0.375)?(-1*((2*(3*((((t%1+1)%1)-0.25)/0.125)*((((t%1+1)%1)-0.25)/0.125)-2*((((t%1+1)%1)-0.25)/0.125)*((((t%1+1)%1)-0.25)/0.125)*((((t%1+1)%1)-0.25)/0.125))-1))):0)+((((t%1+1)%1)>=0.375&&((t%1+1)%1)<0.5)?((2*(3*((((t%1+1)%1)-0.375)/0.125)*((((t%1+1)%1)-0.375)/0.125)-2*((((t%1+1)%1)-0.375)/0.125)*((((t%1+1)%1)-0.375)/0.125)*((((t%1+1)%1)-0.375)/0.125))-1)):0)+((((t%1+1)%1)>=0.5&&((t%1+1)%1)<0.625)?((0*(Math.sin(2*Math.PI*((((t%1+1)%1)-0.5)/0.125))))+1):0)+((((t%1+1)%1)>=0.625&&((t%1+1)%1)<0.75)?(-1*((2*(3*((((t%1+1)%1)-0.625)/0.125)*((((t%1+1)%1)-0.625)/0.125)-2*((((t%1+1)%1)-0.625)/0.125)*((((t%1+1)%1)-0.625)/0.125)*((((t%1+1)%1)-0.625)/0.125))-1))):0)+((((t%1+1)%1)>=0.75&&((t%1+1)%1)<0.875)?((2*(3*((((t%1+1)%1)-0.75)/0.125)*((((t%1+1)%1)-0.75)/0.125)-2*((((t%1+1)%1)-0.75)/0.125)*((((t%1+1)%1)-0.75)/0.125)*((((t%1+1)%1)-0.75)/0.125))-1)):0)+((((t%1+1)%1)>=0.875&&((t%1+1)%1)<1)?((0*(Math.sin(2*Math.PI*((((t%1+1)%1)-0.875)/0.125))))+1):0)",
        gainFormula: "1"
      },
      {
        name: "Hood Scratch",
        duration: "3",
        scratchFormula: "((((t%1+1)%1)>=0&&((t%1+1)%1)<0.083333)?((2*(3*((((t%1+1)%1)-0)/0.083333)*((((t%1+1)%1)-0)/0.083333)-2*((((t%1+1)%1)-0)/0.083333)*((((t%1+1)%1)-0)/0.083333)*((((t%1+1)%1)-0)/0.083333))-1)):0)+((((t%1+1)%1)>=0.083333&&((t%1+1)%1)<0.166667)?(-1*((2*(3*((((t%1+1)%1)-0.083333)/0.083333)*((((t%1+1)%1)-0.083333)/0.083333)-2*((((t%1+1)%1)-0.083333)/0.083333)*((((t%1+1)%1)-0.083333)/0.083333)*((((t%1+1)%1)-0.083333)/0.083333))-1))):0)+((((t%1+1)%1)>=0.166667&&((t%1+1)%1)<0.25)?((2*(3*((((t%1+1)%1)-0.166667)/0.083333)*((((t%1+1)%1)-0.166667)/0.083333)-2*((((t%1+1)%1)-0.166667)/0.083333)*((((t%1+1)%1)-0.166667)/0.083333)*((((t%1+1)%1)-0.166667)/0.083333))-1)):0)+((((t%1+1)%1)>=0.25&&((t%1+1)%1)<0.333333)?(-1*((2*(3*((((t%1+1)%1)-0.25)/0.083333)*((((t%1+1)%1)-0.25)/0.083333)-2*((((t%1+1)%1)-0.25)/0.083333)*((((t%1+1)%1)-0.25)/0.083333)*((((t%1+1)%1)-0.25)/0.083333))-1))):0)+((((t%1+1)%1)>=0.333333&&((t%1+1)%1)<0.416667)?((2*(3*((((t%1+1)%1)-0.333333)/0.083333)*((((t%1+1)%1)-0.333333)/0.083333)-2*((((t%1+1)%1)-0.333333)/0.083333)*((((t%1+1)%1)-0.333333)/0.083333)*((((t%1+1)%1)-0.333333)/0.083333))-1)):0)+((((t%1+1)%1)>=0.416667&&((t%1+1)%1)<0.5)?((0*((2*(3*((((t%1+1)%1)-0.416667)/0.083333)*((((t%1+1)%1)-0.416667)/0.083333)-2*((((t%1+1)%1)-0.416667)/0.083333)*((((t%1+1)%1)-0.416667)/0.083333)*((((t%1+1)%1)-0.416667)/0.083333))-1)))+1):0)+((((t%1+1)%1)>=0.5&&((t%1+1)%1)<0.583333)?(-1*((2*(3*((((t%1+1)%1)-0.5)/0.083333)*((((t%1+1)%1)-0.5)/0.083333)-2*((((t%1+1)%1)-0.5)/0.083333)*((((t%1+1)%1)-0.5)/0.083333)*((((t%1+1)%1)-0.5)/0.083333))-1))):0)+((((t%1+1)%1)>=0.583333&&((t%1+1)%1)<0.666667)?((2*(3*((((t%1+1)%1)-0.583333)/0.083333)*((((t%1+1)%1)-0.583333)/0.083333)-2*((((t%1+1)%1)-0.583333)/0.083333)*((((t%1+1)%1)-0.583333)/0.083333)*((((t%1+1)%1)-0.583333)/0.083333))-1)):0)+((((t%1+1)%1)>=0.666667&&((t%1+1)%1)<0.75)?((0*((2*(3*((((t%1+1)%1)-0.666667)/0.083333)*((((t%1+1)%1)-0.666667)/0.083333)-2*((((t%1+1)%1)-0.666667)/0.083333)*((((t%1+1)%1)-0.666667)/0.083333)*((((t%1+1)%1)-0.666667)/0.083333))-1)))+1):0)+((((t%1+1)%1)>=0.75&&((t%1+1)%1)<0.833333)?(-1*((2*(3*((((t%1+1)%1)-0.75)/0.083333)*((((t%1+1)%1)-0.75)/0.083333)-2*((((t%1+1)%1)-0.75)/0.083333)*((((t%1+1)%1)-0.75)/0.083333)*((((t%1+1)%1)-0.75)/0.083333))-1))):0)+((((t%1+1)%1)>=0.833333&&((t%1+1)%1)<0.916667)?((2*(3*((((t%1+1)%1)-0.833333)/0.083333)*((((t%1+1)%1)-0.833333)/0.083333)-2*((((t%1+1)%1)-0.833333)/0.083333)*((((t%1+1)%1)-0.833333)/0.083333)*((((t%1+1)%1)-0.833333)/0.083333))-1)):0)+((((t%1+1)%1)>=0.916667&&((t%1+1)%1)<1)?((0*((2*(3*((((t%1+1)%1)-0.916667)/0.083333)*((((t%1+1)%1)-0.916667)/0.083333)-2*((((t%1+1)%1)-0.916667)/0.083333)*((((t%1+1)%1)-0.916667)/0.083333)*((((t%1+1)%1)-0.916667)/0.083333))-1)))+1):0)",
        gainFormula: "1"
      },
      {
        name: "Hood Scratch 2",
        duration: "4",
        scratchFormula: "((((t%1+1)%1)>=0&&((t%1+1)%1)<0.125)?((2*(3*((((t%1+1)%1)-0)/0.125)*((((t%1+1)%1)-0)/0.125)-2*((((t%1+1)%1)-0)/0.125)*((((t%1+1)%1)-0)/0.125)*((((t%1+1)%1)-0)/0.125))-1)):0)+((((t%1+1)%1)>=0.125&&((t%1+1)%1)<0.3125)?((0*((2*(3*((((t%1+1)%1)-0.125)/0.1875)*((((t%1+1)%1)-0.125)/0.1875)-2*((((t%1+1)%1)-0.125)/0.1875)*((((t%1+1)%1)-0.125)/0.1875)*((((t%1+1)%1)-0.125)/0.1875))-1)))+1):0)+((((t%1+1)%1)>=0.3125&&((t%1+1)%1)<0.375)?(-1*((2*(3*((((t%1+1)%1)-0.3125)/0.0625)*((((t%1+1)%1)-0.3125)/0.0625)-2*((((t%1+1)%1)-0.3125)/0.0625)*((((t%1+1)%1)-0.3125)/0.0625)*((((t%1+1)%1)-0.3125)/0.0625))-1))):0)+((((t%1+1)%1)>=0.375&&((t%1+1)%1)<0.4375)?((2*(3*((((t%1+1)%1)-0.375)/0.0625)*((((t%1+1)%1)-0.375)/0.0625)-2*((((t%1+1)%1)-0.375)/0.0625)*((((t%1+1)%1)-0.375)/0.0625)*((((t%1+1)%1)-0.375)/0.0625))-1)):0)+((((t%1+1)%1)>=0.4375&&((t%1+1)%1)<0.5)?(-1*((2*(3*((((t%1+1)%1)-0.4375)/0.0625)*((((t%1+1)%1)-0.4375)/0.0625)-2*((((t%1+1)%1)-0.4375)/0.0625)*((((t%1+1)%1)-0.4375)/0.0625)*((((t%1+1)%1)-0.4375)/0.0625))-1))):0)+((((t%1+1)%1)>=0.5&&((t%1+1)%1)<0.5625)?((2*(3*((((t%1+1)%1)-0.5)/0.0625)*((((t%1+1)%1)-0.5)/0.0625)-2*((((t%1+1)%1)-0.5)/0.0625)*((((t%1+1)%1)-0.5)/0.0625)*((((t%1+1)%1)-0.5)/0.0625))-1)):0)+((((t%1+1)%1)>=0.5625&&((t%1+1)%1)<0.625)?((0*((2*(3*((((t%1+1)%1)-0.5625)/0.0625)*((((t%1+1)%1)-0.5625)/0.0625)-2*((((t%1+1)%1)-0.5625)/0.0625)*((((t%1+1)%1)-0.5625)/0.0625)*((((t%1+1)%1)-0.5625)/0.0625))-1)))+1):0)+((((t%1+1)%1)>=0.625&&((t%1+1)%1)<0.6875)?(-1*((2*(3*((((t%1+1)%1)-0.625)/0.0625)*((((t%1+1)%1)-0.625)/0.0625)-2*((((t%1+1)%1)-0.625)/0.0625)*((((t%1+1)%1)-0.625)/0.0625)*((((t%1+1)%1)-0.625)/0.0625))-1))):0)+((((t%1+1)%1)>=0.6875&&((t%1+1)%1)<0.75)?((2*(3*((((t%1+1)%1)-0.6875)/0.0625)*((((t%1+1)%1)-0.6875)/0.0625)-2*((((t%1+1)%1)-0.6875)/0.0625)*((((t%1+1)%1)-0.6875)/0.0625)*((((t%1+1)%1)-0.6875)/0.0625))-1)):0)+((((t%1+1)%1)>=0.75&&((t%1+1)%1)<0.8125)?((0*((2*(3*((((t%1+1)%1)-0.75)/0.0625)*((((t%1+1)%1)-0.75)/0.0625)-2*((((t%1+1)%1)-0.75)/0.0625)*((((t%1+1)%1)-0.75)/0.0625)*((((t%1+1)%1)-0.75)/0.0625))-1)))+1):0)+((((t%1+1)%1)>=0.8125&&((t%1+1)%1)<0.875)?(-1*((2*(3*((((t%1+1)%1)-0.8125)/0.0625)*((((t%1+1)%1)-0.8125)/0.0625)-2*((((t%1+1)%1)-0.8125)/0.0625)*((((t%1+1)%1)-0.8125)/0.0625)*((((t%1+1)%1)-0.8125)/0.0625))-1))):0)+((((t%1+1)%1)>=0.875&&((t%1+1)%1)<0.9375)?((2*(3*((((t%1+1)%1)-0.875)/0.0625)*((((t%1+1)%1)-0.875)/0.0625)-2*((((t%1+1)%1)-0.875)/0.0625)*((((t%1+1)%1)-0.875)/0.0625)*((((t%1+1)%1)-0.875)/0.0625))-1)):0)+((((t%1+1)%1)>=0.9375&&((t%1+1)%1)<1)?((0*((2*(3*((((t%1+1)%1)-0.9375)/0.0625)*((((t%1+1)%1)-0.9375)/0.0625)-2*((((t%1+1)%1)-0.9375)/0.0625)*((((t%1+1)%1)-0.9375)/0.0625)*((((t%1+1)%1)-0.9375)/0.0625))-1)))+1):0)",
        gainFormula: "1"
      }
    ];

    async function renderPresetGrid(forceRedrawWaves = false) {
      presetGrid.innerHTML = '';
      presets.forEach((p, idx) => {
        const node = presetCardTpl.content.cloneNode(true);
        node.querySelector('.pname').textContent = p.name;
        node.querySelector('.beats').textContent = `${p.duration} beat(s)`;
        const card = node.querySelector('.preset-card');
        const mini = node.querySelector('.mini-wave');
        const cScratch = node.querySelector('.curve-scratch');
        const cGain = node.querySelector('.curve-gain');
        const playBtn = node.querySelector('.playBtn');
        const dlBtn = node.querySelector('.dlBtn');

        // initial curves + mini waveform prerender
        const sr = sampleBuffer?.sampleRate || 44100;
        const bpm = parseFloat(bpmEl.value || '120');
        const beatDur = 60 / (isFinite(bpm) ? bpm : 120);
        const samples = Math.max(1, Math.floor((beatDur * (parseInt(p.duration) || 1)) * sr));

        if (sampleBuffer) {
          const preview = synthesizePreviewBuffer(p);
          drawMiniFromBuffer(mini, preview, null);
        }

        playBtn.addEventListener('click', async () => { const i = idx; await handlePlayPreset(i, playBtn, mini); });
        dlBtn.addEventListener('click', async () => { const i = idx; await handleDownloadPreset(i); });
        mini.addEventListener('click', async () => { await handlePlayPreset(idx, playBtn, mini); });

        presetGrid.appendChild(node);
      });
    }

    function synthesizePreviewBuffer(preset) {
      if (!sampleBuffer) return null;

      const bpm = parseFloat(bpmEl.value || '120');
      const beatDur = 60 / (isFinite(bpm) ? bpm : 120);
      const beats = parseInt(preset.duration, 10) || 1;
      const scratchDur = beatDur * beats;

      const sr = sampleBuffer.sampleRate;
      const scratchSamples = Math.max(1, Math.floor(scratchDur * sr));
      const scratchCurve = curveFromFormula(preset.scratchFormula, scratchSamples, -1, 1);
      const gainCurve = curveFromFormula(preset.gainFormula, scratchSamples, 0, 1);

      const sStart = Math.floor(clipStart * sr);
      const sEnd = Math.floor(clipEnd * sr);
      const sLen = Math.max(1, sEnd - sStart);

      // --- NEW: compute tail length if enabled ---
      const tailSrcRemaining = Math.max(0, sampleBuffer.length - sStart);
      const rampSamples = Math.floor(sr * (torqueMs / 1000));
      const tailOutSamples = tailMode === 'none'
        ? 0
        : computeTailOutSamples(tailSrcRemaining, rampSamples);

      const outLen = scratchSamples + tailOutSamples;
      const out = new AudioBuffer({ length: outLen, numberOfChannels: 1, sampleRate: sr });
      const inData = sampleBuffer.getChannelData(0);
      const outData = out.getChannelData(0);

      // scratch part
      for (let i = 0; i < scratchSamples; i++) {
        const u = (scratchCurve[i] + 1) * 0.5;
        const srcPos = sStart + u * (sLen - 1);
        const v = sampleLinear(inData, srcPos);
        outData[i] = v * gainCurve[i];
      }

      // --- NEW: tail part with torque ramp ---
      if (tailOutSamples > 0) {
        let pos = sStart;
        for (let i = 0; i < tailOutSamples; i++) {
          const inc = speedRampIndexIncrement(i, rampSamples);
          const dst = scratchSamples + i;
          if (dst >= outLen || pos >= inData.length) break;
          outData[dst] = sampleLinear(inData, pos);
          pos += inc;
        }
      }

      return out;
    }

    async function updatePresetThumbnails() {
      // First rebuild the preset grid
      renderPresetGrid(true);

      // Then loop over all preset cards and draw mini-wave previews
      const cards = presetGrid.querySelectorAll('.preset-card');
      cards.forEach((card, idx) => {
        const mini = card.querySelector('.mini-wave');
        if (!mini) return;
        const preview = synthesizePreviewBuffer(presets[idx]);
        if (preview) {
          drawMiniFromBuffer(mini, preview, null);
        }
      });
    }

    async function handlePlayPreset(i, buttonEl, miniCanvas) {
      try { await audioCtx.resume(); const rendered = await renderEffectToBuffer(presets[i]); const src = audioCtx.createBufferSource(); src.buffer = rendered; src.connect(audioCtx.destination); src.start(); buttonEl.textContent = 'Stop'; startPlayhead('mini', rendered.duration, miniCanvas, i, () => { buttonEl.textContent = 'Listen'; }); buttonEl.onclick = () => { stopPlayhead(); buttonEl.textContent = 'Listen'; }; } catch (err) { globalStatus.textContent = err.message; }
    }

    async function handleDownloadPreset(i) { try { const rendered = await renderEffectToBuffer(presets[i]); const wav = audioBufferToWav(rendered); const url = URL.createObjectURL(wav); const a = document.createElement('a'); a.href = url; a.download = `${presets[i].name.replace(/[^a-z0-9_-]+/ig, '_')}.wav`; a.click(); globalStatus.textContent = `${presets[i].name} downloaded`; } catch (err) { globalStatus.textContent = err.message; } }

    function audioBufferToWav(buffer) { const numCh = buffer.numberOfChannels; const sampleRate = buffer.sampleRate; const length = buffer.length; const bps = 2; const blockAlign = numCh * bps; const byteRate = sampleRate * blockAlign; const dataSize = length * blockAlign; const total = 44 + dataSize; const ab = new ArrayBuffer(total); const dv = new DataView(ab); let p = 0; function w8(v) { dv.setUint8(p++, v); } function w16(v) { dv.setUint16(p, v, true); p += 2; } function w32(v) { dv.setUint32(p, v, true); p += 4; } w8(0x52); w8(0x49); w8(0x46); w8(0x46); w32(36 + dataSize); w8(0x57); w8(0x41); w8(0x56); w8(0x45); w8(0x66); w8(0x6d); w8(0x74); w8(0x20); w32(16); w16(1); w16(numCh); w32(sampleRate); w32(byteRate); w16(blockAlign); w16(16); w8(0x64); w8(0x61); w8(0x74); w8(0x61); w32(dataSize); const chans = []; for (let ch = 0; ch < numCh; ch++) chans.push(buffer.getChannelData(ch)); for (let i = 0; i < length; i++) { for (let ch = 0; ch < numCh; ch++) { let s = Math.max(-1, Math.min(1, chans[ch][i])); s = s < 0 ? s * 0x8000 : s * 0x7fff; dv.setInt16(p, s, true); p += 2; } } return new Blob([ab], { type: 'audio/wav' }); }

    function startPlayhead(where, duration, canvas = null, miniIdx = -1, onEnd = null) {
      playhead.active = true; playhead.startAt = audioCtx.currentTime; playhead.duration = duration; playhead.where = where; playhead.canvas = canvas; playhead.miniIdx = miniIdx; if (rafId) cancelAnimationFrame(rafId);
      const tick = () => { const t = audioCtx.currentTime - playhead.startAt; if (t >= duration) { stopPlayhead(); onEnd && onEnd(); return; } if (where === 'main') drawMainWave(); else if (where === 'pre') drawPreWave(); else if (where === 'mini' && canvas) { const buf = synthesizePreviewBuffer(presets[miniIdx]); drawMiniFromBuffer(canvas, buf, t / duration); } rafId = requestAnimationFrame(tick); };
      rafId = requestAnimationFrame(tick);
    }
    function stopPlayhead() { playhead.active = false; if (rafId) cancelAnimationFrame(rafId); rafId = null; if (playhead.where === 'main') drawMainWave(); if (playhead.where === 'pre') drawPreWave(); if (playhead.where === 'mini' && playhead.canvas) { const buf = synthesizePreviewBuffer(presets[playhead.miniIdx]); drawMiniFromBuffer(playhead.canvas, buf, null); } playhead.where = 'none'; }

    function init() { fitCanvasToDisplay(preCanvas); fitCanvasToDisplay(waveCanvas); drawPreWave(); drawMainWave(); updateLabels(); renderPresetGrid(); }
    init();
  </script>
</body>

</html>
